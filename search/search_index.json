{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"semantify3 API Documentation","text":"<p>semantify\u00b3 - Extract knowledge graph ready triples from human-readable annotations wherever possible.</p> <p>Syntax matters!</p> <p>Created: 2025-01-29 Authors: Wolfgang Fahl, Tim Holzheim Repository: https://github.com/BITPlan/semantify3</p>"},{"location":"#sem3.extractor","title":"<code>extractor</code>","text":"<p>Command-line interface for semantify\u00b3.</p> <pre><code># \ud83c\udf10\ud83d\udd78\nextractor:\n  isA: PythonModule\n  author: Wolfgang Fahl\n  createdAt: 2025-11-29\n  purpose: extraction of relevant markup snippets for semantify\u00b3.\n</code></pre>"},{"location":"#sem3.extractor.Extractor","title":"<code>Extractor</code>","text":"<p>Extract semantic annotation markup from files.</p> Source code in <code>sem3/extractor.py</code> <pre><code>class Extractor:\n    \"\"\"Extract semantic annotation markup from files.\"\"\"\n\n    def __init__(self, marker: str = \"\ud83c\udf10\ud83d\udd78\", debug: bool = False):\n        \"\"\"constructor.\"\"\"\n        self.marker = marker\n        self.debug = debug\n        self.logger = logging.getLogger(__name__)\n        self.logger.setLevel(logging.DEBUG if debug else logging.INFO)\n\n    def log(self, msg: str):\n        if self.debug:\n            self.logger.debug(msg)\n\n    def extract_from_file(self, filepath: str) -&gt; List[Markup]:\n        \"\"\"Extract markup snippets from a single file.\n\n        Args:\n            filepath: Path to the file to extract from.\n\n        Returns:\n            List[Markup]: List of extracted markup snippets.\n        \"\"\"\n        markups = []\n        try:\n            with open(filepath, \"r\", encoding=\"utf-8\") as f:\n                content = f.read()\n            markups = self.extract_from_text(content, source_path=filepath)\n        except (IOError, UnicodeDecodeError) as e:\n            self.logger.warning(f\"Error reading {filepath}: {e}\")\n            markups = []\n        return markups\n\n    def extract_from_text(\n        self, text: str, source_path: Optional[str] = None\n    ) -&gt; List[Markup]:\n        \"\"\"Extract all semantic markup snippets from text.\n\n        Args:\n            text: The source text to extract from.\n            source_path: Optional file path for location tracking.\n\n        Returns:\n            List[Markup]: List of extracted markup snippets.\n        \"\"\"\n        markups = []\n\n        # Pattern to match code blocks with yaml or sidif\n        pattern = re.compile(\n            r\"```(yaml|sidif)\\s*\\n\"  # Opening fence with language\n            r\"(.*?)\"  # Content (non-greedy)\n            r\"\\n\\s*```\",  # Closing fence\n            re.DOTALL,\n        )\n\n        for match in pattern.finditer(text):\n            lang = match.group(1)\n            raw_content = match.group(2)\n\n            # Find first non-empty line\n            lines = raw_content.split(\"\\n\")\n            first_content_idx = None\n\n            for idx, line in enumerate(lines):\n                if line.strip():\n                    first_content_idx = idx\n                    break\n\n            if first_content_idx is None:\n                continue\n\n            first_line = lines[first_content_idx].strip()\n\n            # Check for marker\n            if self.marker not in first_line:\n                continue\n\n            # Extract content after marker line\n            content_lines = lines[first_content_idx + 1 :]\n            code = \"\\n\".join(content_lines).strip()\n\n            if not code:\n                continue\n\n            # Calculate source line (1-based)\n            line_num = text[: match.start()].count(\"\\n\") + 1\n\n            source = \"\"\n            if source_path:\n                source = f\"{source_path}:{line_num}\"\n\n            markup = Markup(lang=lang, code=code, source=source)\n            markups.append(markup)\n\n        if self.debug and len(markups) &gt; 0:\n            self.log(f\"Found {len(markups)} snippets in {source_path}\")\n\n        return markups\n\n    def extract_from_glob(self, pattern: str) -&gt; List[Markup]:\n        \"\"\"Extract markup snippets from files matching a glob pattern.\n\n        Args:\n            pattern: Glob pattern to match files (supports **).\n\n        Returns:\n            List[Markup]: All markup snippets from matching files.\n        \"\"\"\n        all_markups = []\n\n        files = glob.glob(pattern, recursive=True)\n        self.log(f\"Glob pattern '{pattern}' found {len(files)} files\")\n\n        for filepath in files:\n            markups = self.extract_from_file(filepath)\n            all_markups.extend(markups)\n\n        return all_markups\n\n    def extract_from_glob_list(self, patterns: List[str]) -&gt; List[Markup]:\n        \"\"\"Extract markup snippets from files matching multiple glob patterns.\n\n        Args:\n            patterns: List of glob patterns to match files.\n\n        Returns:\n            List[Markup]: All markup snippets from matching files.\n        \"\"\"\n        all_markups = []\n\n        self.log(f\"Processing {len(patterns)} glob patterns\")\n\n        for pattern in patterns:\n            self.log(f\"Checking pattern: {pattern}\")\n            markups = self.extract_from_glob(pattern)\n            all_markups.extend(markups)\n\n        return all_markups\n</code></pre>"},{"location":"#sem3.extractor.Extractor.__init__","title":"<code>__init__(marker='\ud83c\udf10\ud83d\udd78', debug=False)</code>","text":"<p>constructor.</p> Source code in <code>sem3/extractor.py</code> <pre><code>def __init__(self, marker: str = \"\ud83c\udf10\ud83d\udd78\", debug: bool = False):\n    \"\"\"constructor.\"\"\"\n    self.marker = marker\n    self.debug = debug\n    self.logger = logging.getLogger(__name__)\n    self.logger.setLevel(logging.DEBUG if debug else logging.INFO)\n</code></pre>"},{"location":"#sem3.extractor.Extractor.extract_from_file","title":"<code>extract_from_file(filepath)</code>","text":"<p>Extract markup snippets from a single file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the file to extract from.</p> required <p>Returns:</p> Type Description <code>List[Markup]</code> <p>List[Markup]: List of extracted markup snippets.</p> Source code in <code>sem3/extractor.py</code> <pre><code>def extract_from_file(self, filepath: str) -&gt; List[Markup]:\n    \"\"\"Extract markup snippets from a single file.\n\n    Args:\n        filepath: Path to the file to extract from.\n\n    Returns:\n        List[Markup]: List of extracted markup snippets.\n    \"\"\"\n    markups = []\n    try:\n        with open(filepath, \"r\", encoding=\"utf-8\") as f:\n            content = f.read()\n        markups = self.extract_from_text(content, source_path=filepath)\n    except (IOError, UnicodeDecodeError) as e:\n        self.logger.warning(f\"Error reading {filepath}: {e}\")\n        markups = []\n    return markups\n</code></pre>"},{"location":"#sem3.extractor.Extractor.extract_from_glob","title":"<code>extract_from_glob(pattern)</code>","text":"<p>Extract markup snippets from files matching a glob pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>Glob pattern to match files (supports **).</p> required <p>Returns:</p> Type Description <code>List[Markup]</code> <p>List[Markup]: All markup snippets from matching files.</p> Source code in <code>sem3/extractor.py</code> <pre><code>def extract_from_glob(self, pattern: str) -&gt; List[Markup]:\n    \"\"\"Extract markup snippets from files matching a glob pattern.\n\n    Args:\n        pattern: Glob pattern to match files (supports **).\n\n    Returns:\n        List[Markup]: All markup snippets from matching files.\n    \"\"\"\n    all_markups = []\n\n    files = glob.glob(pattern, recursive=True)\n    self.log(f\"Glob pattern '{pattern}' found {len(files)} files\")\n\n    for filepath in files:\n        markups = self.extract_from_file(filepath)\n        all_markups.extend(markups)\n\n    return all_markups\n</code></pre>"},{"location":"#sem3.extractor.Extractor.extract_from_glob_list","title":"<code>extract_from_glob_list(patterns)</code>","text":"<p>Extract markup snippets from files matching multiple glob patterns.</p> <p>Parameters:</p> Name Type Description Default <code>patterns</code> <code>List[str]</code> <p>List of glob patterns to match files.</p> required <p>Returns:</p> Type Description <code>List[Markup]</code> <p>List[Markup]: All markup snippets from matching files.</p> Source code in <code>sem3/extractor.py</code> <pre><code>def extract_from_glob_list(self, patterns: List[str]) -&gt; List[Markup]:\n    \"\"\"Extract markup snippets from files matching multiple glob patterns.\n\n    Args:\n        patterns: List of glob patterns to match files.\n\n    Returns:\n        List[Markup]: All markup snippets from matching files.\n    \"\"\"\n    all_markups = []\n\n    self.log(f\"Processing {len(patterns)} glob patterns\")\n\n    for pattern in patterns:\n        self.log(f\"Checking pattern: {pattern}\")\n        markups = self.extract_from_glob(pattern)\n        all_markups.extend(markups)\n\n    return all_markups\n</code></pre>"},{"location":"#sem3.extractor.Extractor.extract_from_text","title":"<code>extract_from_text(text, source_path=None)</code>","text":"<p>Extract all semantic markup snippets from text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The source text to extract from.</p> required <code>source_path</code> <code>Optional[str]</code> <p>Optional file path for location tracking.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Markup]</code> <p>List[Markup]: List of extracted markup snippets.</p> Source code in <code>sem3/extractor.py</code> <pre><code>def extract_from_text(\n    self, text: str, source_path: Optional[str] = None\n) -&gt; List[Markup]:\n    \"\"\"Extract all semantic markup snippets from text.\n\n    Args:\n        text: The source text to extract from.\n        source_path: Optional file path for location tracking.\n\n    Returns:\n        List[Markup]: List of extracted markup snippets.\n    \"\"\"\n    markups = []\n\n    # Pattern to match code blocks with yaml or sidif\n    pattern = re.compile(\n        r\"```(yaml|sidif)\\s*\\n\"  # Opening fence with language\n        r\"(.*?)\"  # Content (non-greedy)\n        r\"\\n\\s*```\",  # Closing fence\n        re.DOTALL,\n    )\n\n    for match in pattern.finditer(text):\n        lang = match.group(1)\n        raw_content = match.group(2)\n\n        # Find first non-empty line\n        lines = raw_content.split(\"\\n\")\n        first_content_idx = None\n\n        for idx, line in enumerate(lines):\n            if line.strip():\n                first_content_idx = idx\n                break\n\n        if first_content_idx is None:\n            continue\n\n        first_line = lines[first_content_idx].strip()\n\n        # Check for marker\n        if self.marker not in first_line:\n            continue\n\n        # Extract content after marker line\n        content_lines = lines[first_content_idx + 1 :]\n        code = \"\\n\".join(content_lines).strip()\n\n        if not code:\n            continue\n\n        # Calculate source line (1-based)\n        line_num = text[: match.start()].count(\"\\n\") + 1\n\n        source = \"\"\n        if source_path:\n            source = f\"{source_path}:{line_num}\"\n\n        markup = Markup(lang=lang, code=code, source=source)\n        markups.append(markup)\n\n    if self.debug and len(markups) &gt; 0:\n        self.log(f\"Found {len(markups)} snippets in {source_path}\")\n\n    return markups\n</code></pre>"},{"location":"#sem3.extractor.Markup","title":"<code>Markup</code>  <code>dataclass</code>","text":"<p>A single markup.</p> Source code in <code>sem3/extractor.py</code> <pre><code>@lod_storable\n@dataclass\nclass Markup:\n    \"\"\"A single markup.\"\"\"\n\n    lang: str\n    code: str\n    source: str\n</code></pre>"},{"location":"#sem3.sem3_cmd","title":"<code>sem3_cmd</code>","text":"<p>Command-line interface for semantify\u00b3.</p> <pre><code>\ud83c\udf10\ud83d\udd78\nsem3_cmd:\n  isA: PythonModule\n  author: Wolfgang Fahl\n  createdAt: 2025-11-29\n  purpose: Command-line interface for semantify\u00b3.\n</code></pre>"},{"location":"#sem3.sem3_cmd.Semantify3Cmd","title":"<code>Semantify3Cmd</code>","text":"<p>               Bases: <code>BaseCmd</code></p> <p>Command line interface for semantify\u00b3.</p> Source code in <code>sem3/sem3_cmd.py</code> <pre><code>class Semantify3Cmd(BaseCmd):\n    \"\"\"Command line interface for semantify\u00b3.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the semantify\u00b3 command.\"\"\"\n        super().__init__(version=Version, description=Version.description)\n\n    def get_arg_parser(self) -&gt; ArgumentParser:\n        \"\"\"Create and configure the argument parser.\n\n        Returns:\n            ArgumentParser: The configured argument parser.\n        \"\"\"\n        parser = super().get_arg_parser()\n        parser.add_argument('files', type=argparse.FileType('r'), nargs='*')\n\n        parser.add_argument(\n            \"-i\",\n            \"--input\",\n            type=str,\n            help=\"Input file glob expression\",\n        )\n        parser.add_argument(\n            \"-o\",\n            \"--output\",\n            type=str,\n            help=\"Output file path for triples\",\n        )\n        parser.add_argument(\n            \"--format\",\n            type=str,\n            choices=[\n                \"turtle\",\n                \"n3\",\n                \"ntriples\",\n                \"xml\",\n                \"json-ld\",\n                \"sidif\",\n                \"graphml\",  # Supported by Gremlin and Neo4j (via APOC)\n                \"graphson\",  # Gremlin specific JSON\n                \"cypher\",  # Neo4j Cypher CREATE statements\n            ],\n            default=\"turtle\",\n            help=\"Output serialization format (default: turtle)\",\n        )\n        return parser\n\n    def handle_args(self, args: Namespace) -&gt; bool:\n        \"\"\"Handle parsed arguments.\n\n        Args:\n            args: Parsed argument namespace.\n\n        Returns:\n            bool: True if handled, False otherwise.\n        \"\"\"\n        handled = super().handle_args(args)\n        if handled:\n            return True\n\n        if args.input or args.files:\n            extractor = Extractor(debug=self.debug)\n            markups = []\n            if args.input:\n                markups.extend(extractor.extract_from_glob(args.input))\n            if args.files:\n                for file_path in args.files:\n                    markups.extend(extractor.extract_from_file(file_path))\n            if args.verbose:\n                print(f\"Found {len(markups)} markups\")\n            for i, markup in enumerate(markups):\n                print(f\"{i+1}: {markup.lang} in {os.path.basename(markup.source)}\")\n                print(markup.code)\n                print(\"-\" * 20)\n        return True\n\n        return False\n</code></pre>"},{"location":"#sem3.sem3_cmd.Semantify3Cmd.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the semantify\u00b3 command.</p> Source code in <code>sem3/sem3_cmd.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the semantify\u00b3 command.\"\"\"\n    super().__init__(version=Version, description=Version.description)\n</code></pre>"},{"location":"#sem3.sem3_cmd.Semantify3Cmd.get_arg_parser","title":"<code>get_arg_parser()</code>","text":"<p>Create and configure the argument parser.</p> <p>Returns:</p> Name Type Description <code>ArgumentParser</code> <code>ArgumentParser</code> <p>The configured argument parser.</p> Source code in <code>sem3/sem3_cmd.py</code> <pre><code>def get_arg_parser(self) -&gt; ArgumentParser:\n    \"\"\"Create and configure the argument parser.\n\n    Returns:\n        ArgumentParser: The configured argument parser.\n    \"\"\"\n    parser = super().get_arg_parser()\n    parser.add_argument('files', type=argparse.FileType('r'), nargs='*')\n\n    parser.add_argument(\n        \"-i\",\n        \"--input\",\n        type=str,\n        help=\"Input file glob expression\",\n    )\n    parser.add_argument(\n        \"-o\",\n        \"--output\",\n        type=str,\n        help=\"Output file path for triples\",\n    )\n    parser.add_argument(\n        \"--format\",\n        type=str,\n        choices=[\n            \"turtle\",\n            \"n3\",\n            \"ntriples\",\n            \"xml\",\n            \"json-ld\",\n            \"sidif\",\n            \"graphml\",  # Supported by Gremlin and Neo4j (via APOC)\n            \"graphson\",  # Gremlin specific JSON\n            \"cypher\",  # Neo4j Cypher CREATE statements\n        ],\n        default=\"turtle\",\n        help=\"Output serialization format (default: turtle)\",\n    )\n    return parser\n</code></pre>"},{"location":"#sem3.sem3_cmd.Semantify3Cmd.handle_args","title":"<code>handle_args(args)</code>","text":"<p>Handle parsed arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>Parsed argument namespace.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if handled, False otherwise.</p> Source code in <code>sem3/sem3_cmd.py</code> <pre><code>def handle_args(self, args: Namespace) -&gt; bool:\n    \"\"\"Handle parsed arguments.\n\n    Args:\n        args: Parsed argument namespace.\n\n    Returns:\n        bool: True if handled, False otherwise.\n    \"\"\"\n    handled = super().handle_args(args)\n    if handled:\n        return True\n\n    if args.input or args.files:\n        extractor = Extractor(debug=self.debug)\n        markups = []\n        if args.input:\n            markups.extend(extractor.extract_from_glob(args.input))\n        if args.files:\n            for file_path in args.files:\n                markups.extend(extractor.extract_from_file(file_path))\n        if args.verbose:\n            print(f\"Found {len(markups)} markups\")\n        for i, markup in enumerate(markups):\n            print(f\"{i+1}: {markup.lang} in {os.path.basename(markup.source)}\")\n            print(markup.code)\n            print(\"-\" * 20)\n    return True\n\n    return False\n</code></pre>"},{"location":"#sem3.sem3_cmd.main","title":"<code>main(argv=None)</code>","text":"<p>Main entry point for semantify3 CLI.</p> <p>Parameters:</p> Name Type Description Default <code>argv</code> <p>Command line arguments.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Exit code.</p> Source code in <code>sem3/sem3_cmd.py</code> <pre><code>def main(argv=None) -&gt; int:\n    \"\"\"Main entry point for semantify3 CLI.\n\n    Args:\n        argv: Command line arguments.\n\n    Returns:\n        int: Exit code.\n    \"\"\"\n    cmd = Semantify3Cmd()\n    return cmd.run(argv)\n</code></pre>"},{"location":"#sem3.version","title":"<code>version</code>","text":"<p>Created on 2025-11-29.</p> <p>@author: wf</p>"},{"location":"#sem3.version.Version","title":"<code>Version</code>","text":"<p>Version handling for semantify\u00b3.</p> Source code in <code>sem3/version.py</code> <pre><code>@lod_storable\nclass Version:\n    \"\"\"Version handling for semantify\u00b3.\"\"\"\n\n    name = \"semantify\u00b3\"\n    version = sem3.__version__\n    date = \"2025-11-29\"\n    updated = \"2025-11-29\"\n    description = \"Extract knowledge graph ready triples from human-readable annotations wherever possible \u2014 Syntax matters!\"\n\n    authors = \"Wolfgang Fahl, Tim Holzheim\"\n\n    doc_url = \"https://wiki.bitplan.com/index.php/semantify3\"\n    chat_url = \"https://github.com/BITPlan/semantify3/discussions\"\n    cm_url = \"https://github.com/BITPlan/semantify3\"\n\n    license = \"\"\"Copyright 2025 contributors. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n\n    longDescription = f\"\"\"{name} version {version}\n{description}\n\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"}]}